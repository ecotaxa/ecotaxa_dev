# coding: utf-8

"""
    EcoTaxa

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.0.2
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from to_back.ecotaxa_cli_py.configuration import Configuration


class EMLMeta(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'titles': 'list[EMLTitle]',
        'creators': 'list[EMLPerson]',
        'metadata_providers': 'list[EMLPerson]',
        'associated_parties': 'list[EMLAssociatedPerson]',
        'contacts': 'list[EMLPerson]',
        'pub_date': 'str',
        'language': 'str',
        'abstract': 'list[str]',
        'keyword_set': 'EMLKeywordSet',
        'additional_info': 'str',
        'geographic_coverage': 'EMLGeoCoverage',
        'temporal_coverage': 'EMLTemporalCoverage',
        'general_taxonomic_coverage': 'str',
        'taxonomic_coverage': 'list[EMLTaxonomicClassification]',
        'intellectual_rights': 'str',
        'purpose': 'str',
        'methods': 'EMLMethod',
        'project': 'EMLProject',
        'maintenance_update_frequency': 'str',
        'maintenance': 'str',
        'additional_metadata': 'EMLAdditionalMeta'
    }

    attribute_map = {
        'titles': 'titles',
        'creators': 'creators',
        'metadata_providers': 'metadataProviders',
        'associated_parties': 'associatedParties',
        'contacts': 'contacts',
        'pub_date': 'pubDate',
        'language': 'language',
        'abstract': 'abstract',
        'keyword_set': 'keywordSet',
        'additional_info': 'additionalInfo',
        'geographic_coverage': 'geographicCoverage',
        'temporal_coverage': 'temporalCoverage',
        'general_taxonomic_coverage': 'generalTaxonomicCoverage',
        'taxonomic_coverage': 'taxonomicCoverage',
        'intellectual_rights': 'intellectualRights',
        'purpose': 'purpose',
        'methods': 'methods',
        'project': 'project',
        'maintenance_update_frequency': 'maintenanceUpdateFrequency',
        'maintenance': 'maintenance',
        'additional_metadata': 'additionalMetadata'
    }

    def __init__(self, titles=None, creators=None, metadata_providers=None, associated_parties=None, contacts=None, pub_date=None, language='eng', abstract=None, keyword_set=None, additional_info=None, geographic_coverage=None, temporal_coverage=None, general_taxonomic_coverage=None, taxonomic_coverage=None, intellectual_rights=None, purpose=None, methods=None, project=None, maintenance_update_frequency=None, maintenance=None, additional_metadata=None, local_vars_configuration=None):  # noqa: E501
        """EMLMeta - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._titles = None
        self._creators = None
        self._metadata_providers = None
        self._associated_parties = None
        self._contacts = None
        self._pub_date = None
        self._language = None
        self._abstract = None
        self._keyword_set = None
        self._additional_info = None
        self._geographic_coverage = None
        self._temporal_coverage = None
        self._general_taxonomic_coverage = None
        self._taxonomic_coverage = None
        self._intellectual_rights = None
        self._purpose = None
        self._methods = None
        self._project = None
        self._maintenance_update_frequency = None
        self._maintenance = None
        self._additional_metadata = None
        self.discriminator = None

        self.titles = titles
        self.creators = creators
        self.metadata_providers = metadata_providers
        self.associated_parties = associated_parties
        self.contacts = contacts
        self.pub_date = pub_date
        if language is not None:
            self.language = language
        self.abstract = abstract
        self.keyword_set = keyword_set
        if additional_info is not None:
            self.additional_info = additional_info
        self.geographic_coverage = geographic_coverage
        self.temporal_coverage = temporal_coverage
        if general_taxonomic_coverage is not None:
            self.general_taxonomic_coverage = general_taxonomic_coverage
        self.taxonomic_coverage = taxonomic_coverage
        self.intellectual_rights = intellectual_rights
        if purpose is not None:
            self.purpose = purpose
        if methods is not None:
            self.methods = methods
        if project is not None:
            self.project = project
        if maintenance_update_frequency is not None:
            self.maintenance_update_frequency = maintenance_update_frequency
        if maintenance is not None:
            self.maintenance = maintenance
        self.additional_metadata = additional_metadata

    @property
    def titles(self):
        """Gets the titles of this EMLMeta.  # noqa: E501


        :return: The titles of this EMLMeta.  # noqa: E501
        :rtype: list[EMLTitle]
        """
        return self._titles

    @titles.setter
    def titles(self, titles):
        """Sets the titles of this EMLMeta.


        :param titles: The titles of this EMLMeta.  # noqa: E501
        :type: list[EMLTitle]
        """
        if self.local_vars_configuration.client_side_validation and titles is None:  # noqa: E501
            raise ValueError("Invalid value for `titles`, must not be `None`")  # noqa: E501

        self._titles = titles

    @property
    def creators(self):
        """Gets the creators of this EMLMeta.  # noqa: E501


        :return: The creators of this EMLMeta.  # noqa: E501
        :rtype: list[EMLPerson]
        """
        return self._creators

    @creators.setter
    def creators(self, creators):
        """Sets the creators of this EMLMeta.


        :param creators: The creators of this EMLMeta.  # noqa: E501
        :type: list[EMLPerson]
        """
        if self.local_vars_configuration.client_side_validation and creators is None:  # noqa: E501
            raise ValueError("Invalid value for `creators`, must not be `None`")  # noqa: E501

        self._creators = creators

    @property
    def metadata_providers(self):
        """Gets the metadata_providers of this EMLMeta.  # noqa: E501


        :return: The metadata_providers of this EMLMeta.  # noqa: E501
        :rtype: list[EMLPerson]
        """
        return self._metadata_providers

    @metadata_providers.setter
    def metadata_providers(self, metadata_providers):
        """Sets the metadata_providers of this EMLMeta.


        :param metadata_providers: The metadata_providers of this EMLMeta.  # noqa: E501
        :type: list[EMLPerson]
        """
        if self.local_vars_configuration.client_side_validation and metadata_providers is None:  # noqa: E501
            raise ValueError("Invalid value for `metadata_providers`, must not be `None`")  # noqa: E501

        self._metadata_providers = metadata_providers

    @property
    def associated_parties(self):
        """Gets the associated_parties of this EMLMeta.  # noqa: E501


        :return: The associated_parties of this EMLMeta.  # noqa: E501
        :rtype: list[EMLAssociatedPerson]
        """
        return self._associated_parties

    @associated_parties.setter
    def associated_parties(self, associated_parties):
        """Sets the associated_parties of this EMLMeta.


        :param associated_parties: The associated_parties of this EMLMeta.  # noqa: E501
        :type: list[EMLAssociatedPerson]
        """
        if self.local_vars_configuration.client_side_validation and associated_parties is None:  # noqa: E501
            raise ValueError("Invalid value for `associated_parties`, must not be `None`")  # noqa: E501

        self._associated_parties = associated_parties

    @property
    def contacts(self):
        """Gets the contacts of this EMLMeta.  # noqa: E501


        :return: The contacts of this EMLMeta.  # noqa: E501
        :rtype: list[EMLPerson]
        """
        return self._contacts

    @contacts.setter
    def contacts(self, contacts):
        """Sets the contacts of this EMLMeta.


        :param contacts: The contacts of this EMLMeta.  # noqa: E501
        :type: list[EMLPerson]
        """
        if self.local_vars_configuration.client_side_validation and contacts is None:  # noqa: E501
            raise ValueError("Invalid value for `contacts`, must not be `None`")  # noqa: E501

        self._contacts = contacts

    @property
    def pub_date(self):
        """Gets the pub_date of this EMLMeta.  # noqa: E501


        :return: The pub_date of this EMLMeta.  # noqa: E501
        :rtype: str
        """
        return self._pub_date

    @pub_date.setter
    def pub_date(self, pub_date):
        """Sets the pub_date of this EMLMeta.


        :param pub_date: The pub_date of this EMLMeta.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and pub_date is None:  # noqa: E501
            raise ValueError("Invalid value for `pub_date`, must not be `None`")  # noqa: E501

        self._pub_date = pub_date

    @property
    def language(self):
        """Gets the language of this EMLMeta.  # noqa: E501


        :return: The language of this EMLMeta.  # noqa: E501
        :rtype: str
        """
        return self._language

    @language.setter
    def language(self, language):
        """Sets the language of this EMLMeta.


        :param language: The language of this EMLMeta.  # noqa: E501
        :type: str
        """

        self._language = language

    @property
    def abstract(self):
        """Gets the abstract of this EMLMeta.  # noqa: E501


        :return: The abstract of this EMLMeta.  # noqa: E501
        :rtype: list[str]
        """
        return self._abstract

    @abstract.setter
    def abstract(self, abstract):
        """Sets the abstract of this EMLMeta.


        :param abstract: The abstract of this EMLMeta.  # noqa: E501
        :type: list[str]
        """
        if self.local_vars_configuration.client_side_validation and abstract is None:  # noqa: E501
            raise ValueError("Invalid value for `abstract`, must not be `None`")  # noqa: E501

        self._abstract = abstract

    @property
    def keyword_set(self):
        """Gets the keyword_set of this EMLMeta.  # noqa: E501


        :return: The keyword_set of this EMLMeta.  # noqa: E501
        :rtype: EMLKeywordSet
        """
        return self._keyword_set

    @keyword_set.setter
    def keyword_set(self, keyword_set):
        """Sets the keyword_set of this EMLMeta.


        :param keyword_set: The keyword_set of this EMLMeta.  # noqa: E501
        :type: EMLKeywordSet
        """
        if self.local_vars_configuration.client_side_validation and keyword_set is None:  # noqa: E501
            raise ValueError("Invalid value for `keyword_set`, must not be `None`")  # noqa: E501

        self._keyword_set = keyword_set

    @property
    def additional_info(self):
        """Gets the additional_info of this EMLMeta.  # noqa: E501


        :return: The additional_info of this EMLMeta.  # noqa: E501
        :rtype: str
        """
        return self._additional_info

    @additional_info.setter
    def additional_info(self, additional_info):
        """Sets the additional_info of this EMLMeta.


        :param additional_info: The additional_info of this EMLMeta.  # noqa: E501
        :type: str
        """

        self._additional_info = additional_info

    @property
    def geographic_coverage(self):
        """Gets the geographic_coverage of this EMLMeta.  # noqa: E501


        :return: The geographic_coverage of this EMLMeta.  # noqa: E501
        :rtype: EMLGeoCoverage
        """
        return self._geographic_coverage

    @geographic_coverage.setter
    def geographic_coverage(self, geographic_coverage):
        """Sets the geographic_coverage of this EMLMeta.


        :param geographic_coverage: The geographic_coverage of this EMLMeta.  # noqa: E501
        :type: EMLGeoCoverage
        """
        if self.local_vars_configuration.client_side_validation and geographic_coverage is None:  # noqa: E501
            raise ValueError("Invalid value for `geographic_coverage`, must not be `None`")  # noqa: E501

        self._geographic_coverage = geographic_coverage

    @property
    def temporal_coverage(self):
        """Gets the temporal_coverage of this EMLMeta.  # noqa: E501


        :return: The temporal_coverage of this EMLMeta.  # noqa: E501
        :rtype: EMLTemporalCoverage
        """
        return self._temporal_coverage

    @temporal_coverage.setter
    def temporal_coverage(self, temporal_coverage):
        """Sets the temporal_coverage of this EMLMeta.


        :param temporal_coverage: The temporal_coverage of this EMLMeta.  # noqa: E501
        :type: EMLTemporalCoverage
        """
        if self.local_vars_configuration.client_side_validation and temporal_coverage is None:  # noqa: E501
            raise ValueError("Invalid value for `temporal_coverage`, must not be `None`")  # noqa: E501

        self._temporal_coverage = temporal_coverage

    @property
    def general_taxonomic_coverage(self):
        """Gets the general_taxonomic_coverage of this EMLMeta.  # noqa: E501


        :return: The general_taxonomic_coverage of this EMLMeta.  # noqa: E501
        :rtype: str
        """
        return self._general_taxonomic_coverage

    @general_taxonomic_coverage.setter
    def general_taxonomic_coverage(self, general_taxonomic_coverage):
        """Sets the general_taxonomic_coverage of this EMLMeta.


        :param general_taxonomic_coverage: The general_taxonomic_coverage of this EMLMeta.  # noqa: E501
        :type: str
        """

        self._general_taxonomic_coverage = general_taxonomic_coverage

    @property
    def taxonomic_coverage(self):
        """Gets the taxonomic_coverage of this EMLMeta.  # noqa: E501


        :return: The taxonomic_coverage of this EMLMeta.  # noqa: E501
        :rtype: list[EMLTaxonomicClassification]
        """
        return self._taxonomic_coverage

    @taxonomic_coverage.setter
    def taxonomic_coverage(self, taxonomic_coverage):
        """Sets the taxonomic_coverage of this EMLMeta.


        :param taxonomic_coverage: The taxonomic_coverage of this EMLMeta.  # noqa: E501
        :type: list[EMLTaxonomicClassification]
        """
        if self.local_vars_configuration.client_side_validation and taxonomic_coverage is None:  # noqa: E501
            raise ValueError("Invalid value for `taxonomic_coverage`, must not be `None`")  # noqa: E501

        self._taxonomic_coverage = taxonomic_coverage

    @property
    def intellectual_rights(self):
        """Gets the intellectual_rights of this EMLMeta.  # noqa: E501


        :return: The intellectual_rights of this EMLMeta.  # noqa: E501
        :rtype: str
        """
        return self._intellectual_rights

    @intellectual_rights.setter
    def intellectual_rights(self, intellectual_rights):
        """Sets the intellectual_rights of this EMLMeta.


        :param intellectual_rights: The intellectual_rights of this EMLMeta.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and intellectual_rights is None:  # noqa: E501
            raise ValueError("Invalid value for `intellectual_rights`, must not be `None`")  # noqa: E501

        self._intellectual_rights = intellectual_rights

    @property
    def purpose(self):
        """Gets the purpose of this EMLMeta.  # noqa: E501


        :return: The purpose of this EMLMeta.  # noqa: E501
        :rtype: str
        """
        return self._purpose

    @purpose.setter
    def purpose(self, purpose):
        """Sets the purpose of this EMLMeta.


        :param purpose: The purpose of this EMLMeta.  # noqa: E501
        :type: str
        """

        self._purpose = purpose

    @property
    def methods(self):
        """Gets the methods of this EMLMeta.  # noqa: E501


        :return: The methods of this EMLMeta.  # noqa: E501
        :rtype: EMLMethod
        """
        return self._methods

    @methods.setter
    def methods(self, methods):
        """Sets the methods of this EMLMeta.


        :param methods: The methods of this EMLMeta.  # noqa: E501
        :type: EMLMethod
        """

        self._methods = methods

    @property
    def project(self):
        """Gets the project of this EMLMeta.  # noqa: E501


        :return: The project of this EMLMeta.  # noqa: E501
        :rtype: EMLProject
        """
        return self._project

    @project.setter
    def project(self, project):
        """Sets the project of this EMLMeta.


        :param project: The project of this EMLMeta.  # noqa: E501
        :type: EMLProject
        """

        self._project = project

    @property
    def maintenance_update_frequency(self):
        """Gets the maintenance_update_frequency of this EMLMeta.  # noqa: E501


        :return: The maintenance_update_frequency of this EMLMeta.  # noqa: E501
        :rtype: str
        """
        return self._maintenance_update_frequency

    @maintenance_update_frequency.setter
    def maintenance_update_frequency(self, maintenance_update_frequency):
        """Sets the maintenance_update_frequency of this EMLMeta.


        :param maintenance_update_frequency: The maintenance_update_frequency of this EMLMeta.  # noqa: E501
        :type: str
        """

        self._maintenance_update_frequency = maintenance_update_frequency

    @property
    def maintenance(self):
        """Gets the maintenance of this EMLMeta.  # noqa: E501


        :return: The maintenance of this EMLMeta.  # noqa: E501
        :rtype: str
        """
        return self._maintenance

    @maintenance.setter
    def maintenance(self, maintenance):
        """Sets the maintenance of this EMLMeta.


        :param maintenance: The maintenance of this EMLMeta.  # noqa: E501
        :type: str
        """

        self._maintenance = maintenance

    @property
    def additional_metadata(self):
        """Gets the additional_metadata of this EMLMeta.  # noqa: E501


        :return: The additional_metadata of this EMLMeta.  # noqa: E501
        :rtype: EMLAdditionalMeta
        """
        return self._additional_metadata

    @additional_metadata.setter
    def additional_metadata(self, additional_metadata):
        """Sets the additional_metadata of this EMLMeta.


        :param additional_metadata: The additional_metadata of this EMLMeta.  # noqa: E501
        :type: EMLAdditionalMeta
        """
        if self.local_vars_configuration.client_side_validation and additional_metadata is None:  # noqa: E501
            raise ValueError("Invalid value for `additional_metadata`, must not be `None`")  # noqa: E501

        self._additional_metadata = additional_metadata

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, EMLMeta):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, EMLMeta):
            return True

        return self.to_dict() != other.to_dict()
